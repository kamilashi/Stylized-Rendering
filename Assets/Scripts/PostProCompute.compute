
#pragma kernel Outline
#pragma kernel CombineDistortiondMap
#pragma kernel DisortionAlongVelocity

Texture2D<float4> source;
Texture2D<float4> outlineMap;
shared RWTexture2D<float4> outputOutline;

Texture2D<float4> distortionMap;
RWTexture2D<float4> outputPreDistortion;
RWTexture2D<float4> outputPostDistortion;

int2 screenResolution;
float outlineThreshold;
bool outlineMapView;

float skewAngle;
int lengthOfVector; // temp
float2 cameraVelocity;
bool distortionMapView;

float inverseLerp(float a, float b, float v)
{
    return (v - a) / (b - a);
}

float remap(float iMin, float iMax, float oMin, float oMax, float v)
{
    float t = inverseLerp(iMin, iMax, v);
    return lerp(oMin, oMax, t);
}

bool withinScreen(uint2 id)
{
    if ((id.x < 0) ||
        (id.x >= screenResolution.x))
    {
        return false;
    }
    if ((id.y < 0) ||
        (id.y >= screenResolution.y))
    {
        return false;
    }
    return true;
}

uint2 clampWithinScreen(uint2 id)
{
    id.x = min(id.x, screenResolution.x);
    id.x = max(id.x, 0);
    id.y = min(id.y, screenResolution.y);
    id.y = max(id.y, 0);
    
    return id;
}

uint2 absV2(uint2 id)
{
    id.x = max(id.x, -id.x);
    id.y = max(id.y, -id.y);
    
    return id;
}

[numthreads(64, 16, 1)]
void Outline(uint3 id : SV_DispatchThreadID)
{
    float3 thisPixelColor = float3(outlineMap[id.xy].x, outlineMap[id.xy].y, outlineMap[id.xy].z);
    float4 thisPixel = outlineMap[id.xy];
    float4 thisPixelSource = source[id.xy];
    float outline = 0;
    
    float thisPixelColorLength = length(thisPixelColor);
    
    if ((thisPixelColorLength == 0) || (outlineMapView && !distortionMapView))
    {
        outputOutline[id.xy] = thisPixel;
        return;
    }
    
    uint2 lowerPixelId = uint2(id.x, (id.y + 1));
        
    if (withinScreen(lowerPixelId))
    {
        float3 lowerPixelColor = float3(outlineMap[lowerPixelId].x, outlineMap[lowerPixelId].y, outlineMap[lowerPixelId].z);
        float4 lowerPixel = outlineMap[lowerPixelId];
        if (abs(length(lowerPixelColor) - thisPixelColorLength) > outlineThreshold)
        {
            thisPixel = float4(0, 0, 0, 1);
            outline = 1;

        }
    }
    
    uint2 rightPixelId = uint2((id.x + 1), (id.y));
    if (withinScreen(rightPixelId))
    {
        float3 rightPixelColor = float3(outlineMap[rightPixelId].x, outlineMap[rightPixelId].y, outlineMap[rightPixelId].z);
        float4 rightPixel = outlineMap[rightPixelId];
        if (abs(length(rightPixelColor) - thisPixelColorLength) > outlineThreshold)
        {
            thisPixel = float4(0, 0, 0, 1);
            outline = 1;
        }
    }
    
    outputOutline[id.xy] = lerp(thisPixelSource, thisPixel, outline);
}

[numthreads(64, 16, 1)]
void CombineDistortiondMap(uint3 id : SV_DispatchThreadID)
{
    float4 thisPixelSource = outputOutline[id.xy];
    float4 thisPixelDistortion = distortionMap[id.xy];
    float hasDistortionTexture = thisPixelDistortion.w; //(0): no billboard to distort; (1): has billboard to distort; 
    
    if (distortionMapView && !outlineMapView)
    {
        outputPreDistortion[id.xy] = thisPixelDistortion;
        return;
    }
    
    outputPreDistortion[id.xy] = lerp(thisPixelSource, thisPixelDistortion, hasDistortionTexture);
 }

[numthreads(64, 16, 1)]
void DisortionAlongVelocity(uint3 id : SV_DispatchThreadID)
{
    //uint count = (uint) ceil(length(cameraVelocity));
    uint count = (uint) abs(lengthOfVector);
    
    uint2 velocityOffset = (uint2) cameraVelocity;
    float4 thisPixelSource = outputPreDistortion[id.xy];
    float4 thisPixelDistortion = distortionMap[id.xy];
    
    float hasDistortionTexture = thisPixelDistortion.w;
    float weight = thisPixelDistortion.w;
    
    float4 currentPixel = outputPreDistortion[id.xy];
    if ( /*hasDistortionTexture > 0.0f &&*/count * hasDistortionTexture > 0.0f)
    {
         [unroll(50)]
        for (int x = 0; x < count*2 ; ++x)
        {
           // uint2 index = id.xy - absV2((uint2) (velocityOffset)) * count + ((uint2) (velocityOffset)) * x;
            uint2 index = id.xy - uint2(count, count) + uint2(x, x);
            
            if (withinScreen(index))
            {
                currentPixel += outputPreDistortion[index]; // * 2.0 * (1.0f - thisPixelDistortion.w);
                weight *= thisPixelDistortion.w;
            }
        }
        clamp(currentPixel, 0.0f, 1.0f);
        currentPixel /= (count * 2);
        currentPixel.w = weight;
    }
    
    outputPostDistortion[id.xy] = currentPixel;
    //outputPostDistortion[id.xy] = lerp(thisPixelSource, currentPixel, hasDistortionTexture);
}
